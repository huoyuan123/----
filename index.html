<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素剑士：手势传说 - 堡垒守卫版</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        /* --- CSS 样式 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #webcam-feed {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 4px solid #4a3b2a;
            z-index: 2;
            display: none;
            opacity: 0.7;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        /* 主菜单：撑满全屏并覆盖在游戏画面之上 */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.15) url('menu.png') no-repeat center center;
            background-size: cover;
            z-index: 9999;
            pointer-events: auto;
            display: block;
        }

        /* 图片内文字已包含，隐藏冗余文本 */
        #main-menu h1, #main-menu p { display: none; }

        /* 主菜单可调热区参数（使用 vmin 以适配长宽比变化）*/
        #main-menu { --btn-y: 18vmin; --btn-gap: 28vmin; --btn-w: 30vmin; --btn-h: 10vmin; }

        /* 将锚点放在屏幕中心，便于 cover 模式下保持对称 */
        .menu-buttons-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0; /* 作为锚点，不参与布局 */
            height: 0;
            pointer-events: none; /* 容器不拦截事件 */
        }

        /* 透明按钮热区：尺寸与位置都基于 vmin，随屏幕同比例缩放 */
        #main-menu .btn {
            position: absolute;
            width: var(--btn-w);
            height: var(--btn-h);
            background: transparent;
            border: none;
            opacity: 0;
            margin: 0;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.08s, opacity 0.12s;
        }

        /* 左侧：手势模式 */
        #btn-gesture {
            transform: translate(-50%, -50%) translateX(calc(-1 * var(--btn-gap))) translateY(var(--btn-y));
        }
        /* 右侧：鼠标模式 */
        #btn-mouse {
            transform: translate(-50%, -50%) translateX(var(--btn-gap)) translateY(var(--btn-y));
        }

        /* 悬停时提供轻微可视化，便于校准 */
        #main-menu .btn:hover { opacity: 0.12; background: #ffffff; border-radius: 12px; }

        h1 { color: #5eff5e; line-height: 1.5; margin-bottom: 30px; }

        .btn {
            display: block;
            margin: 15px auto;
            padding: 15px 30px;
            background: #8b5a2b;
            color: #ffd700;
            border: 4px solid #5c3a1e;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.1s;
            text-decoration: none;
        }

        .btn:hover { transform: scale(1.05); background: #a06e3d; }
        .btn:active { transform: scale(0.95); }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            display: none;
            pointer-events: none;
            font-size: 12px;
            line-height: 1.6;
        }
        
        #crafting-menu {
            display: none;
            pointer-events: auto;
            background: rgba(46, 34, 23, 0.95);
            border: 4px solid #ffd700;
            padding: 20px;
            width: 60%;
            height: 60%;
        }

        #loader {
            display: none;
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }

        .hp-text { color: #ff5e5e; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input-video" style="display:none"></video>
    <canvas id="webcam-feed"></canvas>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="main-menu">
            <h1>像素剑士<br><span style="font-size:0.6em; color:#fff;">手势传说</span></h1>
            <p style="font-size: 10px; margin-bottom: 20px; color: #ddd;">保护中心的三座堡垒！</p>
            <div class="menu-buttons-container">
                <button class="btn" id="btn-gesture"></button>
                <button class="btn" id="btn-mouse"></button>
            </div>
            <div id="loader">正在加载 AI 模型...</div>
        </div>

        <div id="hud">
            <div>分数: <span id="score">0</span> | 材料: <span id="materials">0</span></div>
            <div class="hp-text">堡垒A HP: <span id="hp-0">100</span></div>
            <div class="hp-text">堡垒B HP: <span id="hp-1">100</span></div>
            <div class="hp-text">堡垒C HP: <span id="hp-2">100</span></div>
            <div style="font-size: 10px; margin-top: 10px;">[ESC] 打开工坊</div>
        </div>

        <div id="crafting-menu">
            <h2>剑刃工坊</h2>
            <div style="display: flex; justify-content: space-around; margin-top: 50px;">
                <div style="border: 2px dashed #666; padding: 20px;">
                    <p>基础剑 (LV.1)</p>
                    <button class="btn" style="font-size: 10px;">已装备</button>
                </div>
                <div style="border: 2px solid #ffd700; padding: 20px; background: #333;">
                    <p>火焰剑 (LV.5)</p>
                    <p style="font-size:10px; color:red;">需: 50 材料</p>
                    <button class="btn" id="btn-craft" style="font-size: 10px;">锻造</button>
                </div>
            </div>
            <button class="btn" id="btn-close-craft" style="margin-top: 50px;">返回冒险</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- 游戏状态管理 ---
        const STATE = { MENU: 0, PLAYING: 1, CRAFTING: 2, GAMEOVER: 3 };
        let currentState = STATE.MENU;
        let controlMode = 'mouse'; 
        let score = 0;
        let materials = 0;
        let swordLevel = 1; 
        let fireballs = []; 

        // --- 场景变量 ---
        let scene, camera, renderer, sword;
        let enemies = [], particles = [], fortresses = [];
        const mouse = new THREE.Vector2();
        const targetPos = new THREE.Vector3(0, 0, 0); 
        const FRUSTUM_SIZE = 20;

        // --- 初始化 ---
        function initThree() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d4c1e); 

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                FRUSTUM_SIZE * aspect / -2, FRUSTUM_SIZE * aspect / 2,
                FRUSTUM_SIZE / 2, FRUSTUM_SIZE / -2, 0.1, 1000
            );
            camera.position.set(0, 0, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.id = 'game-canvas';
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            createSword();
            createBackground();
            createFortresses(); // 创建三大堡垒

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => { if(currentState === STATE.PLAYING) slashAttack(); });
            window.addEventListener('keydown', (e) => { if(e.key === 'Escape') toggleCrafting(); });
        }

        // --- 核心修改：创建三个堡垒 ---
        function createFortresses() {
            const radius = 2.5; // 堡垒距离中心的距离
            const fortressGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            
            for(let i=0; i<3; i++) {
                const angle = (i * 120 + 90) * (Math.PI / 180); // 等边三角形分布
                const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const fort = new THREE.Mesh(fortressGeo, mat);
                
                fort.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                fort.userData = { hp: 100, id: i };
                
                // 给堡垒加一个小顶端区分
                const roof = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.8), new THREE.MeshStandardMaterial({color: 0xaa0000}));
                roof.position.y = 1;
                fort.add(roof);

                scene.add(fort);
                fortresses.push(fort);
            }
        }

        // 加载剑图并抠掉接近白色的背景，返回纹理与纵横比
        function loadSwordImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width; canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    try {
                        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const d = imgData.data;
                        for (let i = 0; i < d.length; i += 4) {
                            const r = d[i], g = d[i + 1], b = d[i + 2];
                            if (r > 240 && g > 240 && b > 240) d[i + 3] = 0; // 抠白色背景
                        }
                        ctx.putImageData(imgData, 0, 0);
                    } catch (e) {
                        // 某些环境下可能安全限制，忽略抠像，直接使用原图
                    }
                    const tex = new THREE.Texture(canvas);
                    tex.needsUpdate = true;
                    resolve({ texture: tex, aspect: img.width / img.height });
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        function createSword() {
            sword = new THREE.Group();
            scene.add(sword);

            // 加载初始剑.jpg
            loadSwordImage('初始剑.jpg').then(({ texture, aspect }) => {
                const h = 4.5; // 可调：视觉上合适的高度
                const w = h * aspect;
                const geo = new THREE.PlaneGeometry(w, h);
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.renderOrder = 2;
                sword.add(mesh);
                sword.userData.material = mat; // 供锻造变色时使用
            }).catch(() => {
                const hilt = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 3, 0.1), new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2 }));
                blade.position.y = 2.2;
                sword.add(hilt); sword.add(blade);
                sword.userData.material = blade.material;
            });
        }

        // 修改背景加载逻辑
        function createBackground() {
            const loader = new THREE.TextureLoader();
            loader.load('闯关背景.jpg', (texture) => {
                const bgGeo = new THREE.PlaneGeometry(40, 30);
                const bgMat = new THREE.MeshBasicMaterial({ map: texture });
                const bgMesh = new THREE.Mesh(bgGeo, bgMat);
                bgMesh.position.set(0, 0, -10);
                scene.add(bgMesh);
            }, undefined, (err) => {
                console.error('Failed to load background image:', err);
            });
        }

        // --- 核心修改：敌人目标逻辑 ---
        function spawnEnemy() {
            if (currentState !== STATE.PLAYING) return;
            
            const enemy = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
            const angle = Math.random() * Math.PI * 2;
            enemy.position.set(Math.cos(angle) * 15, Math.sin(angle) * 15, 0);
            
            // 随机寻找一个还活着的堡垒作为目标
            const aliveForts = fortresses.filter(f => f.userData.hp > 0);
            const targetFort = aliveForts.length > 0 ? aliveForts[Math.floor(Math.random()*aliveForts.length)] : null;

            enemy.userData = { 
                hp: 1, 
                speed: 0.03 + Math.random() * 0.03,
                theta: 0,
                waveSpeed: 0.05 + Math.random() * 0.1, 
                waveAmp: 0.5 + Math.random() * 1.5,
                target: targetFort
            };
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function createParticles(pos) {
            for(let i=0; i<5; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                p.position.copy(pos);
                p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, 0), life: 30 };
                scene.add(p); particles.push(p);
            }
        }

        // --- 逻辑更新 ---
        function updateGame() {
            if (currentState !== STATE.PLAYING) return;

            sword.position.lerp(targetPos, 0.2);
            sword.rotation.z = -new THREE.Vector3().subVectors(targetPos, sword.position).x * 2; 

            // 火球
            for (let i = fireballs.length - 1; i >= 0; i--) {
                const fb = fireballs[i];
                fb.position.add(fb.userData.velocity);
                fb.userData.life--;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (fb.position.distanceTo(enemies[j].position) < 2.0) {
                        createParticles(enemies[j].position);
                        scene.remove(enemies[j]); enemies.splice(j, 1);
                        score += 150; materials += 2; updateHUD();
                        fb.userData.life = 0; break; 
                    }
                }
                if (fb.userData.life <= 0) { scene.remove(fb); fireballs.splice(i, 1); }
            }

            // 敌人与堡垒碰撞检测
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const data = enemy.userData;
                
                // 如果目标堡垒没了，换一个
                if(!data.target || data.target.userData.hp <= 0) {
                    const aliveForts = fortresses.filter(f => f.userData.hp > 0);
                    data.target = aliveForts[Math.floor(Math.random()*aliveForts.length)];
                }

                if(data.target) {
                    const dirToTarget = new THREE.Vector3().subVectors(data.target.position, enemy.position).normalize();
                    const sideDir = new THREE.Vector3(-dirToTarget.y, dirToTarget.x, 0);
                    enemy.position.add(dirToTarget.multiplyScalar(data.speed));
                    data.theta += data.waveSpeed;
                    enemy.position.add(sideDir.multiplyScalar(Math.sin(data.theta) * data.waveAmp * 0.05));
                }

                enemy.rotation.z += 0.05;

                // 玩家击杀
                if (sword.position.distanceTo(enemy.position) < 2.0) {
                    createParticles(enemy.position);
                    scene.remove(enemy); enemies.splice(i, 1);
                    score += 100; materials += 2; updateHUD();
                    continue;
                }

                // 核心修改：堡垒碰撞逻辑
                if (data.target && enemy.position.distanceTo(data.target.position) < 1.2) {
                    data.target.userData.hp -= 10;
                    createParticles(enemy.position);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                    
                    if(data.target.userData.hp <= 0) {
                        data.target.material.color.set(0x111111); // 堡垒损毁变黑
                    }
                    updateHUD();
                    checkGameOver();
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].position.add(particles[i].userData.vel);
                if(--particles[i].userData.life <= 0) { scene.remove(particles[i]); particles.splice(i, 1); }
            }
        }

        function checkGameOver() {
            const totalHP = fortresses.reduce((sum, f) => sum + Math.max(0, f.userData.hp), 0);
            if (totalHP <= 0) {
                currentState = STATE.GAMEOVER;
                alert("所有堡垒已沦陷！最终得分: " + score);
                location.reload();
            }
        }

        // --- 其余功能维持原状 ---
        function onMouseMove(event) {
            if (controlMode !== 'mouse') return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const aspect = window.innerWidth / window.innerHeight;
            targetPos.set(mouse.x * (FRUSTUM_SIZE * aspect / 2), mouse.y * (FRUSTUM_SIZE / 2), 0);
        }

        function slashAttack() {
            sword.rotation.z -= 1.5; 
            if (swordLevel >= 5) {
                const fireball = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.9 }));
                fireball.position.copy(sword.position);
                const direction = new THREE.Vector3(0, 1, 0).applyQuaternion(sword.quaternion).normalize();
                fireball.userData = { velocity: direction.multiplyScalar(0.4), life: 150 };
                scene.add(fireball); fireballs.push(fireball);
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -FRUSTUM_SIZE * aspect / 2; camera.right = FRUSTUM_SIZE * aspect / 2;
            camera.top = FRUSTUM_SIZE / 2; camera.bottom = -FRUSTUM_SIZE / 2;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateHUD() {
            document.getElementById('score').innerText = score;
            document.getElementById('materials').innerText = materials;
            fortresses.forEach((f, i) => {
                document.getElementById(`hp-${i}`).innerText = Math.max(0, f.userData.hp);
            });
        }

        function toggleCrafting() {
            const craftMenu = document.getElementById('crafting-menu');
            if(currentState === STATE.PLAYING) { currentState = STATE.CRAFTING; craftMenu.style.display = 'block'; }
            else if (currentState === STATE.CRAFTING) { currentState = STATE.PLAYING; craftMenu.style.display = 'none'; }
        }

        // MediaPipe
        function setupMediaPipe() {
            document.getElementById('loader').style.display = 'block';
            const videoElement = document.getElementById('input-video');
            const canvasElement = document.getElementById('webcam-feed');
            const canvasCtx = canvasElement.getContext('2d');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults((results) => {
                canvasCtx.save(); canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const indexTip = landmarks[8];
                    if (controlMode === 'gesture' && currentState === STATE.PLAYING) {
                        const aspect = window.innerWidth / window.innerHeight;
                        targetPos.set((0.5 - indexTip.x) * (FRUSTUM_SIZE * aspect * 1.5), (0.5 - indexTip.y) * (FRUSTUM_SIZE * 1.5), 0);
                        if(new THREE.Vector3().subVectors(targetPos, sword.position).length() > 1.2) slashAttack();
                    }
                }
                canvasCtx.restore();
            });
            const cameraUtils = new window.Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
            cameraUtils.start().then(() => { document.getElementById('loader').style.display = 'none'; startGame('gesture'); }).catch(() => alert("无法启动摄像头"));
        }

        document.getElementById('btn-mouse').addEventListener('click', () => startGame('mouse'));
        document.getElementById('btn-gesture').addEventListener('click', setupMediaPipe);
        document.getElementById('btn-close-craft').addEventListener('click', toggleCrafting);
        document.getElementById('btn-craft').addEventListener('click', () => {
            if (materials >= 50) {
                materials -= 50; swordLevel = 5; 
                sword.children[1].material.color.set(0xff3300); 
                sword.children[1].material.emissive = new THREE.Color(0xff0000);
                updateHUD(); alert("火焰剑锻造成功！挥动鼠标或手势即可发射火球！"); toggleCrafting();
            } else alert("材料不足！");
        });

        function startGame(mode) {
            controlMode = mode;
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            if(mode === 'gesture') document.getElementById('webcam-feed').style.display = 'block';
            currentState = STATE.PLAYING;
            setInterval(spawnEnemy, 2000); 
        }

        function animate() { requestAnimationFrame(animate); updateGame(); renderer.render(scene, camera); }
        initThree(); animate();
    </script>
</body>
</html>