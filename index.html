<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素剑士：手势传说 - 堡垒守卫版</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
                /* 菜单BGM按钮显眼样式 */
                #btn-menu-bgm {
                    position: fixed !important;
                    top: 20px !important;
                    right: 20px !important;
                    z-index: 10000 !important;
                    font-size: 14px !important;
                    background: #222 !important;
                    color: #ffd700 !important;
                    border: 2px solid #ffd700 !important;
                    opacity: 1 !important;
                    pointer-events: auto !important;
                }
        /* --- CSS 样式 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* 调整摄像头的透明度，确保不被背景遮挡 */
        #webcam-feed {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 4px solid #4a3b2a;
            z-index: 20; /* 提升层级，确保在背景之上 */
            display: none;
            opacity: 0.9; /* 提高透明度，避免完全被挡住 */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        /* 主菜单：撑满全屏并覆盖在游戏画面之上 */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.15) url('menu.png') no-repeat center center;
            background-size: cover;
            z-index: 9999;
            pointer-events: auto;
            display: block;
        }

        /* 图片内文字已包含，隐藏冗余文本 */
        #main-menu h1, #main-menu p { display: none; }

        /* 主菜单可调热区参数（使用 vmin 以适配长宽比变化）*/
        #main-menu { --btn-y: 18vmin; --btn-gap: 28vmin; --btn-w: 30vmin; --btn-h: 10vmin; }

        /* 将锚点放在屏幕中心，便于 cover 模式下保持对称 */
        .menu-buttons-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0; /* 作为锚点，不参与布局 */
            height: 0;
            pointer-events: none; /* 容器不拦截事件 */
        }

        /* 透明按钮热区：尺寸与位置都基于 vmin，随屏幕同比例缩放 */
        #main-menu .btn {
            position: absolute;
            width: var(--btn-w);
            height: var(--btn-h);
            background: transparent;
            border: none;
            opacity: 0;
            margin: 0;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.08s, opacity 0.12s;
        }

        /* 左侧：手势模式 */
        #btn-gesture {
            transform: translate(-50%, -50%) translateX(calc(-1 * var(--btn-gap))) translateY(var(--btn-y));
        }
        /* 右侧：鼠标模式 */
        #btn-mouse {
            transform: translate(-50%, -50%) translateX(var(--btn-gap)) translateY(var(--btn-y));
        }

        /* 悬停时提供轻微可视化，便于校准 */
        #main-menu .btn:hover { opacity: 0.12; background: #ffffff; border-radius: 12px; }

        h1 { color: #5eff5e; line-height: 1.5; margin-bottom: 30px; }

        .btn {
            display: block;
            margin: 15px auto;
            padding: 15px 30px;
            background: #8b5a2b;
            color: #ffd700;
            border: 4px solid #5c3a1e;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.1s;
            text-decoration: none;
        }

        .btn:hover { transform: scale(1.05); background: #a06e3d; }
        .btn:active { transform: scale(0.95); }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            display: none;
            pointer-events: none;
            font-size: 12px;
            line-height: 1.6;
            text-shadow: none; /* 移除阴影 */
            color: black; /* 设置文字颜色为黑色 */
        }
        
        #crafting-menu {
            display: none;
            pointer-events: auto;
            background: rgba(46, 34, 23, 0.95);
            border: 4px solid #ffd700;
            padding: 20px;
            width: 60%;
            height: 60%;
        }

        #loader {
            display: none;
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }

        .hp-text { color: #ff5e5e; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <button id="backMenuBtn" style="position: fixed; right: 30px; top: 30px; z-index: 10001; padding: 10px 24px; font-size: 18px; background: #ffd700; color: #222; border: 2px solid #222; border-radius: 8px; cursor: pointer; display: none;">返回菜单</button>

    <video id="input-video" style="display:none"></video>
    <canvas id="webcam-feed"></canvas>

    <!-- 主菜单背景音乐 -->
    <audio id="menu-bgm" preload="auto" loop>
        <source src="park bird - Are You Lost_H.ogg" type="audio/ogg">
    </audio>

    <!-- 游戏内背景音乐 -->
    <audio id="bgm" preload="auto" loop>
        <source src="Tobu%20-%20Higher.flac" type="audio/flac">
    </audio>

    <!-- 剑与飞镖碰撞音效 -->
    <audio id="hit-sfx" preload="auto">
        <source src="碰撞声音.mp3" type="audio/mpeg">
    </audio>
    <!-- 堡垒受击音效 -->
    <audio id="fortress-hit-sfx" preload="auto">
        <source src="堡垒受击.mp3" type="audio/mpeg">
    </audio>

    <!-- UI 点击音效（任意可交互选项点击时播放） -->
    <audio id="click-sfx" preload="auto">
        <source src="点击音效.mp3" type="audio/mpeg">
    </audio>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="main-menu">
            <h1>像素剑士<br><span style="font-size:0.6em; color:#fff;">手势传说</span></h1>
            <p style="font-size: 10px; margin-bottom: 20px; color: #ddd;">保护中心的三座堡垒！</p>
            <button class="btn" id="btn-menu-bgm">菜单BGM: ON</button>
            <div class="menu-buttons-container">
                <button class="btn" id="btn-gesture"></button>
                <button class="btn" id="btn-mouse"></button>
            </div>
            <div id="loader">正在加载 AI 模型...</div>
        </div>

        <!-- 模式选择弹窗 -->
        <div id="mode-popup" style="display:none; position:fixed; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.5); z-index:10000; justify-content:center; align-items:center; pointer-events:auto;">
            <div style="background:#222; color:#ffd700; border:4px solid #ffd700; border-radius:16px; padding:40px 32px; text-align:center; min-width:260px; font-family:'Press Start 2P',cursive; box-shadow:0 0 24px #000; position:relative;">
                <button id="close-popup-btn" style="position:absolute; top:12px; right:16px; background:none; border:none; color:#ffd700; font-size:22px; cursor:pointer;">×</button>
                <h2 style="margin-bottom:32px; font-size:22px;">请选择操作</h2>
                <button class="btn" id="continue-game-btn" style="width:160px; margin-bottom:18px;">继续游戏</button><br>
                <button class="btn" id="restart-game-btn" style="width:160px;">重新开始</button>
            </div>
        </div>

        <div id="hud">
            <div>分数: <span id="score">0</span> | 材料: <span id="materials">0</span></div>
            <div class="hp-text">堡垒A HP: <span id="hp-0">100</span></div>
            <div class="hp-text">堡垒B HP: <span id="hp-1">100</span></div>
            <div class="hp-text">堡垒C HP: <span id="hp-2">100</span></div>
            <div style="margin-top: 10px;">
                <button class="btn" id="btn-bgm" style="font-size: 10px; pointer-events: auto;">BGM: ON</button>
            </div>
            <div style="font-size: 10px; margin-top: 10px;">[ESC] 打开工坊</div>
        </div>

        <div id="crafting-menu">
            <h2>剑刃工坊</h2>
            <div style="display: flex; justify-content: space-around; margin-top: 50px;">
                <div style="border: 2px dashed #666; padding: 20px;">
                    <p>基础剑 (LV.1)</p>
                    <button class="btn" style="font-size: 10px;">已装备</button>
                </div>
                <div style="border: 2px solid #ffd700; padding: 20px; background: #333;">
                    <p>火焰剑 (LV.5)</p>
                    <p style="font-size:10px; color:red;">需: 30 材料</p>
                    <button class="btn" id="btn-craft" style="font-size: 10px;">锻造</button>
                </div>
            </div>
            <button class="btn" id="btn-close-craft" style="margin-top: 50px;">返回冒险</button>
        </div>
    </div>

    <script type="module">
                    // 关闭弹窗按钮（需在弹窗渲染后绑定事件）
                    setTimeout(() => {
                        const closeBtn = document.getElementById('close-popup-btn');
                        if (closeBtn) closeBtn.onclick = hideModePopup;
                    }, 0);
                // 仅在游戏界面显示返回菜单按钮
                function showBackMenuBtn(show) {
                    document.getElementById('backMenuBtn').style.display = show ? 'block' : 'none';
                }

                // 修改 startGame 逻辑，进入游戏时显示返回菜单按钮
                const originalStartGame = startGame;
                startGame = function(mode) {
                    showBackMenuBtn(true);
                    originalStartGame(mode);
                };

                // 返回菜单按钮跳转主菜单
                document.getElementById('backMenuBtn').addEventListener('click', function() {
                    document.getElementById('hud').style.display = 'none';
                    document.getElementById('main-menu').style.display = 'block';
                    showBackMenuBtn(false);
                    // 可选：暂停游戏内BGM，恢复菜单BGM
                    if (typeof menuBgmEl !== 'undefined' && menuBgmEl) {
                        try { menuBgmEl.play(); } catch {}
                    }
                    if (typeof bgmEl !== 'undefined' && bgmEl) {
                        try { bgmEl.pause(); } catch {}
                    }
                    currentState = STATE.MENU;
                });
            // 返回菜单按钮跳转主菜单
            document.getElementById('backMenuBtn').addEventListener('click', function() {
                document.getElementById('hud').style.display = 'none';
                document.getElementById('main-menu').style.display = 'block';
                // 可选：暂停游戏内BGM，恢复菜单BGM
                if (typeof menuBgmEl !== 'undefined' && menuBgmEl) {
                    try { menuBgmEl.play(); } catch {}
                }
                if (typeof bgmEl !== 'undefined' && bgmEl) {
                    try { bgmEl.pause(); } catch {}
                }
                currentState = STATE.MENU;
            });
        import * as THREE from 'three';

        // --- 游戏状态管理 ---
        const STATE = { MENU: 0, PLAYING: 1, CRAFTING: 2, GAMEOVER: 3 };
        let currentState = STATE.MENU;
        let controlMode = 'mouse'; 
        let score = 0;
        let materials = 0;
        let swordLevel = 1; 
        let fireballs = []; 
        let lastFireballTime = 0;
        let spawnEnemyIntervalId = null;

        // --- 存档（继续游戏/重新开始） ---
        const GAME_SAVE_KEY = 'gameSave';
        let saveDebounceId = null;
        let pendingFortressHp = null;

        function requestSaveGameState() {
            if (saveDebounceId !== null) return;
            saveDebounceId = setTimeout(() => {
                saveDebounceId = null;
                saveGameState();
            }, 200);
        }

        function saveGameState() {
            try {
                const data = {
                    v: 1,
                    ts: Date.now(),
                    score,
                    materials,
                    swordLevel,
                    fortressHp: fortresses.map(f => typeof f?.userData?.hp === 'number' ? f.userData.hp : 100)
                };
                localStorage.setItem(GAME_SAVE_KEY, JSON.stringify(data));
            } catch (e) {
                // 忽略存档失败
            }
        }

        function applySaveData(data) {
            if (!data || typeof data !== 'object') return;

            if (typeof data.score === 'number') score = data.score;
            if (typeof data.materials === 'number') materials = data.materials;
            if (typeof data.swordLevel === 'number') swordLevel = data.swordLevel;

            if (Array.isArray(data.fortressHp) && data.fortressHp.length >= 3) {
                if (fortresses.length >= 3) {
                    fortresses.forEach((f, i) => {
                        if (!f?.userData) f.userData = {};
                        const hp = data.fortressHp[i];
                        f.userData.hp = typeof hp === 'number' ? hp : 100;
                    });
                } else {
                    pendingFortressHp = data.fortressHp;
                }
            }

            // 恢复武器外观（火焰剑）
            if (swordLevel >= 5) {
                try { if (sword) scene.remove(sword); } catch {}
                try { createFlameSword(); } catch {}
            }

            updateHUD();
        }

        function resetGameState() {
            score = 0;
            materials = 0;
            swordLevel = 1;
            lastFireballTime = 0;

            // 清理敌人/粒子/火球
            try {
                enemies.forEach(e => { try { scene.remove(e); } catch {} });
                particles.forEach(p => { try { scene.remove(p); } catch {} });
                fireballs.forEach(fb => { try { scene.remove(fb); } catch {} });
            } catch {}
            enemies = [];
            particles = [];
            fireballs = [];

            // 重置堡垒血量
            fortresses.forEach((f) => {
                if (!f?.userData) f.userData = {};
                f.userData.hp = 100;
            });

            // 重置武器
            try { if (sword) scene.remove(sword); } catch {}
            try { createSword(); } catch {}

            // 关闭工坊
            const craftMenu = document.getElementById('crafting-menu');
            if (craftMenu) craftMenu.style.display = 'none';

            updateHUD();
            requestSaveGameState();
        }
        const FIREBALL_COOLDOWN_MS = 1000 / 3;
        const FIREBALL_SPEED = 0.12; // 火球速度为飞镖速度的 2 倍

        // --- 主菜单背景音乐 ---
        const MENU_BGM_STORAGE_KEY = 'gesture-legend.menuBgmEnabled';
        const menuBgmEl = document.getElementById('menu-bgm');
        const hitSfxEl = document.getElementById('hit-sfx');
        const clickSfxEl = document.getElementById('click-sfx');
        let menuBgmEnabled = true;

        function playClickSfx() {
            if (!clickSfxEl) return;
            try {
                clickSfxEl.currentTime = 0;
                const p = clickSfxEl.play();
                if (p && typeof p.catch === 'function') p.catch(() => {});
            } catch {}
        }

        function isUiInteractiveTarget(node) {
            if (!(node instanceof Element)) return false;
            const clickable = node.closest(
                [
                    'button',
                    'a[href]',
                    'input[type="button"]',
                    'input[type="submit"]',
                    'input[type="reset"]',
                    'select',
                    'summary',
                    '[role="button"]',
                    '[onclick]',
                    '[data-click-sound]',
                    '.btn'
                ].join(',')
            );
            if (!clickable) return false;
            if (clickable.matches('button:disabled, input:disabled, select:disabled, [aria-disabled="true"]')) return false;
            return true;
        }

        // 全局点击音效：捕获阶段，确保即使按钮内部 stopPropagation 也能响
        document.addEventListener(
            'click',
            (ev) => {
                if (ev.button !== 0) return;
                if (!isUiInteractiveTarget(ev.target)) return;
                playClickSfx();
            },
            true
        );

        // 键盘激活（回车/空格）也补一份（部分自定义控件不会触发 click）
        document.addEventListener(
            'keydown',
            (ev) => {
                if (ev.key !== 'Enter' && ev.key !== ' ') return;
                if (!isUiInteractiveTarget(document.activeElement)) return;
                playClickSfx();
            },
            true
        );

        // 读取本地存储，默认开启
        function loadMenuBgmPreference() {
            // 每次都强制关闭，忽略localStorage
            return false;
        }

        // 更新按钮文本
        function updateMenuBgmButton() {
            const btn = document.getElementById('btn-menu-bgm');
            if (!btn) return;
            btn.innerText = `菜单BGM: ${menuBgmEnabled ? 'ON' : 'OFF'}`;
        }

        // 根据开关播放或暂停音乐
        async function playMenuBgmIfEnabled(reason = 'apply') {
            if (!menuBgmEl) return;
            menuBgmEl.volume = 0.7;
            if (!menuBgmEnabled) {
                try { menuBgmEl.pause(); } catch {}
                return;
            }
            try {
                await menuBgmEl.play();
            } catch (e) {
                if (reason !== 'toggle') console.warn('Menu BGM autoplay blocked:', e);
            }
        }

        // 初始化菜单BGM按钮和状态
        function initMenuBgm() {
            menuBgmEnabled = loadMenuBgmPreference();
            updateMenuBgmButton();
            const btn = document.getElementById('btn-menu-bgm');
            if (btn) {
                btn.addEventListener('click', async () => {
                    menuBgmEnabled = !menuBgmEnabled;
                    localStorage.setItem(MENU_BGM_STORAGE_KEY, menuBgmEnabled ? '1' : '0');
                    updateMenuBgmButton();
                    await playMenuBgmIfEnabled('toggle');
                });
            }
            // 初次进入主菜单时尝试播放一次
            playMenuBgmIfEnabled('init');
        }

        // --- 游戏内背景音乐 ---
        const BGM_STORAGE_KEY = 'gesture-legend.bgmEnabled';
        const bgmEl = document.getElementById('bgm');
        let bgmEnabled = true;

        function loadBgmPreference() {
            const raw = localStorage.getItem(BGM_STORAGE_KEY);
            if (raw === null) return true; // 默认开启
            return raw === '1';
        }

        function updateBgmButton() {
            const btn = document.getElementById('btn-bgm');
            if (!btn) return;
            btn.innerText = `BGM: ${bgmEnabled ? 'ON' : 'OFF'}`;
        }

        async function applyBgmState(nextEnabled, reason = 'apply') {
            bgmEnabled = !!nextEnabled;
            localStorage.setItem(BGM_STORAGE_KEY, bgmEnabled ? '1' : '0');
            updateBgmButton();

            if (!bgmEl) return;
            bgmEl.volume = 0.7;

            if (!bgmEnabled) {
                try { bgmEl.pause(); } catch {}
                return;
            }

            // 浏览器通常要求“用户交互后”才能播放；startGame/按钮点击属于交互
            try {
                await bgmEl.play();
            } catch (e) {
                // 自动播放被拦截时，保持为开启状态，用户再次点击按钮即可播放
                if (reason !== 'toggle') console.warn('BGM autoplay blocked:', e);
            }
        }

        // --- 飞镖抠像资源（用于敌人/材料特效） ---
        const DART_IMAGE_URLS = [
            'images/飞镖 (1).png',
            'images/飞镖 (2).png',
            'images/飞镖 (3).png',
            'images/飞镖 (4).png',
            'images/飞镖 (5).png'
        ];
        let dartSprites = []; // { texture, aspect }
        let dartSpritesReady = false;
        let dartSpritesPromise = null;

        // --- 场景变量 ---
        let scene, camera, renderer, sword;
        let enemies = [], particles = [], fortresses = [];
        const mouse = new THREE.Vector2();
        const targetPos = new THREE.Vector3(0, 0, 0); 
        const FRUSTUM_SIZE = 20;

        // --- 初始化 ---
        function initThree() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d4c1e); 

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                FRUSTUM_SIZE * aspect / -2, FRUSTUM_SIZE * aspect / 2,
                FRUSTUM_SIZE / 2, FRUSTUM_SIZE / -2, 0.1, 1000
            );
            camera.position.set(0, 0, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.id = 'game-canvas';
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            createSword();
            createBackground();
            createFortresses(); // 创建三大堡垒

            // 预加载飞镖抠像贴图（避免战斗中异步加载导致看不到变化）
            preloadDartSprites();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => { if(currentState === STATE.PLAYING) slashAttack(); });
            window.addEventListener('keydown', (e) => { if(e.key === 'Escape') toggleCrafting(); });
        }

        function preloadDartSprites() {
            if (dartSpritesReady) return Promise.resolve(true);
            if (dartSpritesPromise) return dartSpritesPromise;

            dartSpritesPromise = Promise.all(
                DART_IMAGE_URLS.map((url) =>
                    loadSwordImage(url)
                        .then(({ texture, aspect }) => ({ texture, aspect }))
                        .catch((e) => {
                            console.warn('Failed to preload dart image:', url, e);
                            return null;
                        })
                )
            ).then((results) => {
                dartSprites = results.filter(Boolean);
                dartSpritesReady = dartSprites.length > 0;
                return dartSpritesReady;
            });

            return dartSpritesPromise;
        }

        function getRandomDartSprite() {
            if (!dartSpritesReady || dartSprites.length === 0) return null;
            return dartSprites[Math.floor(Math.random() * dartSprites.length)];
        }

        // --- 核心修改：创建三个堡垒 ---
        function createFortresses() {
            const radius = 2.5; // 堡垒距离中心的距离
            const fortressGeo = new THREE.PlaneGeometry(4, 3); // 将堡垒的宽度调整为更宽尺寸

            const loader = new THREE.TextureLoader();
            loader.load('生成塔防小堡垒照片.png', (texture) => {
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        map: { value: texture },
                        keyColor: { value: new THREE.Color(0xffffff) }, // 白色作为抠像颜色
                        threshold: { value: 0.1 } // 设置抠像的阈值
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D map;
                        uniform vec3 keyColor;
                        uniform float threshold;
                        varying vec2 vUv;
                        void main() {
                            vec4 color = texture2D(map, vUv);
                            float diff = distance(color.rgb, keyColor);
                            if (diff < threshold) discard; // 抠掉接近白色的背景
                            gl_FragColor = vec4(color.rgb, color.a);
                        }
                    `,
                    transparent: true
                });

                for (let i = 0; i < 3; i++) {
                    const angle = (i * 120 + 90) * (Math.PI / 180); // 等边三角形分布
                    const fort = new THREE.Mesh(fortressGeo, material);

                    fort.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    fort.userData = { hp: 100, id: i };

                    scene.add(fort);
                    fortresses.push(fort);
                }

                // 若“继续游戏”时堡垒尚未创建，等创建完成后再应用血量
                if (Array.isArray(pendingFortressHp) && pendingFortressHp.length >= 3) {
                    fortresses.forEach((f, i) => {
                        if (!f?.userData) f.userData = {};
                        const hp = pendingFortressHp[i];
                        f.userData.hp = typeof hp === 'number' ? hp : 100;
                    });
                    pendingFortressHp = null;
                    updateHUD();
                }
            }, undefined, (err) => {
                console.error('Failed to load fortress image:', err);
            });
        }

        // 加载剑图并抠掉接近白色的背景，返回纹理与纵横比
        function loadSwordImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width; canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    try {
                        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const d = imgData.data;
                        for (let i = 0; i < d.length; i += 4) {
                            const r = d[i], g = d[i + 1], b = d[i + 2];
                            if (r > 240 && g > 240 && b > 240) d[i + 3] = 0; // 抠白色背景
                        }
                        ctx.putImageData(imgData, 0, 0);
                    } catch (e) {
                        // 某些环境下可能安全限制，忽略抠像，直接使用原图
                    }
                    const tex = new THREE.Texture(canvas);
                    tex.needsUpdate = true;
                    resolve({ texture: tex, aspect: img.width / img.height });
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        function createSword() {
            sword = new THREE.Group();
            scene.add(sword);

            // 加载初始剑.jpg
            loadSwordImage('初始剑.jpg').then(({ texture, aspect }) => {
                const h = 4.5; // 可调：视觉上合适的高度
                const w = h * aspect;
                const geo = new THREE.PlaneGeometry(w, h);
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.renderOrder = 2;
                sword.add(mesh);
                sword.userData.material = mat; // 供锻造变色时使用
            }).catch(() => {
                const hilt = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 3, 0.1), new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2 }));
                blade.position.y = 2.2;
                sword.add(hilt); sword.add(blade);
                sword.userData.material = blade.material;
            });
        }

        // 修改背景加载逻辑，确保背景图撑满全屏
        function createBackground() {
            const loader = new THREE.TextureLoader();
            loader.load('闯关背景.jpg', (texture) => {
                const aspect = window.innerWidth / window.innerHeight;
                const bgWidth = FRUSTUM_SIZE * aspect * 1.2; // 拉宽背景图
                const bgHeight = FRUSTUM_SIZE * 1.2; // 拉高背景图

                const bgGeo = new THREE.PlaneGeometry(bgWidth, bgHeight);
                const bgMat = new THREE.MeshBasicMaterial({ map: texture });
                const bgMesh = new THREE.Mesh(bgGeo, bgMat);
                bgMesh.position.set(0, 0, -10);
                scene.add(bgMesh);
            }, undefined, (err) => {
                console.error('Failed to load background image:', err);
            });
        }

        // --- 核心修改：敌人目标逻辑 ---
        function spawnEnemy() {
            if (currentState !== STATE.PLAYING) return;

            // 用飞镖抠像替换绿色方块敌人：优先用贴图平面，否则回退绿色方块
            const sprite = getRandomDartSprite();
            const enemy = sprite
                ? (() => {
                    const h = 2.2;
                    const w = h * sprite.aspect;
                    const geo = new THREE.PlaneGeometry(w, h);
                    const mat = new THREE.MeshBasicMaterial({
                        map: sprite.texture,
                        transparent: true,
                        depthWrite: false
                    });
                    const m = new THREE.Mesh(geo, mat);
                    m.renderOrder = 3;
                    return m;
                })()
                : new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1.5, 1.5),
                    new THREE.MeshStandardMaterial({ color: 0x00ff00 })
                );
            const angle = Math.random() * Math.PI * 2;
            enemy.position.set(Math.cos(angle) * 15, Math.sin(angle) * 15, 0);
            
            // 随机寻找一个还活着的堡垒作为目标
            const aliveForts = fortresses.filter(f => f.userData.hp > 0);
            const targetFort = aliveForts.length > 0 ? aliveForts[Math.floor(Math.random()*aliveForts.length)] : null;

            enemy.userData = { 
                hp: 1, 
                speed: 0.03 + Math.random() * 0.03,
                theta: 0,
                waveSpeed: 0.05 + Math.random() * 0.1, 
                waveAmp: 0.5 + Math.random() * 1.5,
                target: targetFort
            };
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function createParticles(pos) {
            for (let i = 0; i < 5; i++) {
                const sprite = getRandomDartSprite();
                const p = sprite
                    ? (() => {
                        const h = 0.9;
                        const w = h * sprite.aspect;
                        const geo = new THREE.PlaneGeometry(w, h);
                        const mat = new THREE.MeshBasicMaterial({
                            map: sprite.texture,
                            transparent: true,
                            depthWrite: false
                        });
                        const m = new THREE.Mesh(geo, mat);
                        m.renderOrder = 4;
                        return m;
                    })()
                    : new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.3, 0.3),
                        new THREE.MeshBasicMaterial({ color: 0xffff00 })
                    );

                p.position.copy(pos);
                p.userData = {
                    vel: new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, 0),
                    life: 30
                };
                scene.add(p);
                particles.push(p);
            }
        }

        // --- 逻辑更新 ---
        function updateGame() {
            if (currentState !== STATE.PLAYING) return;

            sword.position.lerp(targetPos, 0.2);
            sword.rotation.z = -new THREE.Vector3().subVectors(targetPos, sword.position).x * 2; 

            // 火球
            for (let i = fireballs.length - 1; i >= 0; i--) {
                const fb = fireballs[i];
                fb.position.add(fb.userData.velocity);
                fb.userData.life--;
                if (fb.userData.updateTail) fb.userData.updateTail();
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (fb.position.distanceTo(enemies[j].position) < 2.0) {
                        createParticles(enemies[j].position);
                        scene.remove(enemies[j]); enemies.splice(j, 1);
                        score += 150; materials += 2; updateHUD();
                        fb.userData.life = 0; break; 
                    }
                }
                if (fb.userData.life <= 0) { scene.remove(fb); fireballs.splice(i, 1); }
            }

            // 敌人与堡垒碰撞检测
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const data = enemy.userData;
                
                // 如果目标堡垒没了，换一个
                if(!data.target || data.target.userData.hp <= 0) {
                    const aliveForts = fortresses.filter(f => f.userData.hp > 0);
                    data.target = aliveForts[Math.floor(Math.random()*aliveForts.length)];
                }

                if(data.target) {
                    const dirToTarget = new THREE.Vector3().subVectors(data.target.position, enemy.position).normalize();
                    const sideDir = new THREE.Vector3(-dirToTarget.y, dirToTarget.x, 0);
                    enemy.position.add(dirToTarget.multiplyScalar(data.speed));
                    data.theta += data.waveSpeed;
                    enemy.position.add(sideDir.multiplyScalar(Math.sin(data.theta) * data.waveAmp * 0.05));
                }

                enemy.rotation.z += 0.05;

                // 玩家击杀
                if (sword.position.distanceTo(enemy.position) < 2.0) {
                    // 播放碰撞音效
                    if (hitSfxEl) {
                        try {
                            hitSfxEl.currentTime = 0;
                            hitSfxEl.play();
                        } catch (e) {}
                    }
                    createParticles(enemy.position);
                    scene.remove(enemy); enemies.splice(i, 1);
                    score += 100; materials += 2; updateHUD();
                    continue;
                }

                // 核心修改：堡垒碰撞逻辑
                if (data.target && enemy.position.distanceTo(data.target.position) < 1.2) {
                    data.target.userData.hp -= 10;
                    createParticles(enemy.position);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                    // 播放堡垒受击音效
                    const fortressHitSfxEl = document.getElementById('fortress-hit-sfx');
                    if (fortressHitSfxEl) {
                        try {
                            fortressHitSfxEl.currentTime = 0;
                            fortressHitSfxEl.play();
                        } catch (e) {}
                    }
                    if(data.target.userData.hp <= 0) {
                        data.target.material.color.set(0x111111); // 堡垒损毁变黑
                    }
                    updateHUD();
                    checkGameOver();
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].position.add(particles[i].userData.vel);
                if(--particles[i].userData.life <= 0) { scene.remove(particles[i]); particles.splice(i, 1); }
            }
        }

        function checkGameOver() {
            const totalHP = fortresses.reduce((sum, f) => sum + Math.max(0, f.userData.hp), 0);
            if (totalHP <= 0) {
                currentState = STATE.GAMEOVER;
                alert("所有堡垒已沦陷！最终得分: " + score);
                location.reload();
            }
        }

        // --- 其余功能维持原状 ---
        function onMouseMove(event) {
            if (controlMode !== 'mouse') return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const aspect = window.innerWidth / window.innerHeight;
            targetPos.set(mouse.x * (FRUSTUM_SIZE * aspect / 2), mouse.y * (FRUSTUM_SIZE / 2), 0);
        }

        function slashAttack() {
            sword.rotation.z -= 1.5; 
            if (swordLevel >= 5) {
                const now = Date.now();
                if (now - lastFireballTime < FIREBALL_COOLDOWN_MS) return; // 每秒最多发射三颗
                lastFireballTime = now;
                sword.updateMatrixWorld(true);
                const swordTip = new THREE.Vector3(0, 1, 0).applyMatrix4(sword.matrixWorld);
                const direction = new THREE.Vector3(0, 1, 0).applyQuaternion(sword.quaternion).normalize();
                loadSwordImage('火球.png').then(({ texture, aspect }) => {
                    const h = 1.1;
                    const w = h * aspect;
                    const geo = new THREE.PlaneGeometry(w, h);
                    const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(swordTip);
                    mesh.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                    mesh.userData = {
                        velocity: direction.clone().multiplyScalar(FIREBALL_SPEED),
                        life: 150,
                        updateTail: function() {
                            const tip = new THREE.Vector3(0, 1, 0).applyMatrix4(sword.matrixWorld);
                            const pos = mesh.position;
                            const dx = tip.x - pos.x;
                            const dy = tip.y - pos.y;
                            mesh.rotation.z = Math.atan2(dy, dx) - Math.PI / 2;
                        }
                    };
                    scene.add(mesh);
                    fireballs.push(mesh);
                });
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -FRUSTUM_SIZE * aspect / 2; camera.right = FRUSTUM_SIZE * aspect / 2;
            camera.top = FRUSTUM_SIZE / 2; camera.bottom = -FRUSTUM_SIZE / 2;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateHUD() {
            document.getElementById('score').innerText = score;
            document.getElementById('materials').innerText = materials;
            fortresses.forEach((f, i) => {
                document.getElementById(`hp-${i}`).innerText = Math.max(0, f.userData.hp);
            });

            if (currentState === STATE.PLAYING) {
                requestSaveGameState();
            }
        }

        function toggleCrafting() {
            const craftMenu = document.getElementById('crafting-menu');
            if(currentState === STATE.PLAYING) { currentState = STATE.CRAFTING; craftMenu.style.display = 'block'; }
            else if (currentState === STATE.CRAFTING) { currentState = STATE.PLAYING; craftMenu.style.display = 'none'; }
        }

        // BGM 初始化（尽早绑定按钮与读取偏好）
        initMenuBgm();
        bgmEnabled = loadBgmPreference();
        updateBgmButton();
        document.getElementById('btn-bgm').addEventListener('click', async () => {
            await applyBgmState(!bgmEnabled, 'toggle');
        });

        // MediaPipe
        function setupMediaPipe() {
            document.getElementById('loader').style.display = 'block';
            const videoElement = document.getElementById('input-video');
            const canvasElement = document.getElementById('webcam-feed');
            const canvasCtx = canvasElement.getContext('2d');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults((results) => {
                canvasCtx.save(); canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const indexTip = landmarks[8];
                    if (controlMode === 'gesture' && currentState === STATE.PLAYING) {
                        const aspect = window.innerWidth / window.innerHeight;
                        targetPos.set((0.5 - indexTip.x) * (FRUSTUM_SIZE * aspect * 1.5), (0.5 - indexTip.y) * (FRUSTUM_SIZE * 1.5), 0);
                        if(new THREE.Vector3().subVectors(targetPos, sword.position).length() > 1.2) slashAttack();
                    }
                }
                canvasCtx.restore();
            });
            const cameraUtils = new window.Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
            cameraUtils.start().then(() => { document.getElementById('loader').style.display = 'none'; startGame('gesture'); }).catch(() => alert("无法启动摄像头"));
        }

        // 模式选择弹窗逻辑
        let selectedMode = null;
        function showModePopup(mode) {
            selectedMode = mode;
            document.getElementById('mode-popup').style.display = 'flex';
        }
        function hideModePopup() {
            document.getElementById('mode-popup').style.display = 'none';
        }

        document.getElementById('btn-mouse').addEventListener('click', () => showModePopup('mouse'));
        document.getElementById('btn-gesture').addEventListener('click', () => showModePopup('gesture'));

        // 继续游戏按钮
        document.getElementById('continue-game-btn').addEventListener('click', () => {
            hideModePopup();

            // 读取存档（没有存档就当作新开一局）
            let raw = null;
            try { raw = localStorage.getItem(GAME_SAVE_KEY); } catch {}

            if (raw) {
                try {
                    applySaveData(JSON.parse(raw));
                } catch {}
            } else {
                resetGameState();
            }

            // 进入游戏
            if (selectedMode === 'gesture') setupMediaPipe();
            else startGame('mouse');
        });

        // 重新开始按钮
        document.getElementById('restart-game-btn').addEventListener('click', () => {
            hideModePopup();

            try { localStorage.removeItem(GAME_SAVE_KEY); } catch {}
            resetGameState();

            // 直接进入新游戏
            if (selectedMode === 'gesture') setupMediaPipe();
            else startGame('mouse');
        });
        document.getElementById('btn-close-craft').addEventListener('click', toggleCrafting);
        document.getElementById('btn-craft').addEventListener('click', () => {
            if (swordLevel >= 5) {
                alert("你已经拥有火焰剑！");
                return;
            }
            if (materials >= 30) {
                materials -= 30;
                swordLevel = 5;
                // 移除初始剑
                scene.remove(sword);
                // 创建并添加火焰剑
                createFlameSword();
                updateHUD();
                alert("火焰剑锻造成功！挥动鼠标或手势即可发射火球！");
                toggleCrafting();
            } else {
                alert("材料不足！");
            }
        });
        // 创建火焰剑及火焰特效
        function createFlameSword() {
            sword = new THREE.Group();
            scene.add(sword);
            loadSwordImage('火焰剑.png').then(({ texture, aspect }) => {
                const h = 4.5;
                const w = h * aspect;
                const geo = new THREE.PlaneGeometry(w, h);
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.renderOrder = 2;
                sword.add(mesh);
                sword.userData.material = mat;
                // 添加火焰特效
                addFlameEffect(sword, w, h);
            }).catch(() => {
                // 加载失败时用默认色块
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 3, 0.1), new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.2 }));
                blade.position.y = 2.2;
                sword.add(blade);
                sword.userData.material = blade.material;
                addFlameEffect(sword, 0.8, 3);
            });
        }

        // 火焰特效：在剑尖添加粒子火焰（避免重叠）
        function addFlameEffect(swordObj, w, h) {
            const flameGroup = new THREE.Group();
            swordObj.add(flameGroup);
            // 粒子数量减少，分布更自然
            const PARTICLE_COUNT = 7;
            function updateFlame() {
                while (flameGroup.children.length > 0) flameGroup.remove(flameGroup.children[0]);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // 让每个粒子分布在不同角度和距离，避免重叠
                    const angle = (Math.PI * 2 / PARTICLE_COUNT) * i + Math.random() * 0.3;
                    const radius = 0.12 + Math.random() * 0.18;
                    const size = 0.13 + Math.random() * 0.09;
                    const geo = new THREE.SphereGeometry(size, 6, 6);
                    const color = new THREE.Color().setHSL(0.05 + Math.random() * 0.08, 1, 0.5 + Math.random() * 0.2);
                    const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.38 + Math.random() * 0.25 });
                    const mesh = new THREE.Mesh(geo, mat);
                    // 让粒子分布在剑尖上方的半圆区域
                    mesh.position.set(Math.cos(angle) * radius, h / 2 + Math.sin(angle) * 0.18 + Math.random() * 0.18, 0);
                    flameGroup.add(mesh);
                }
            }
            function animateFlame() {
                updateFlame();
                requestAnimationFrame(animateFlame);
            }
            animateFlame();
        }

        function startGame(mode) {
            controlMode = mode;
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            if(mode === 'gesture') document.getElementById('webcam-feed').style.display = 'block';
            currentState = STATE.PLAYING;

            // 开局先刷新一次 HUD（确保“继续/重开”的数值立刻显示）
            updateHUD();

            if (spawnEnemyIntervalId !== null) {
                clearInterval(spawnEnemyIntervalId);
                spawnEnemyIntervalId = null;
            }
            spawnEnemyIntervalId = setInterval(spawnEnemy, 2000);

            // 进入游戏时暂停主菜单BGM
            if (menuBgmEl) {
                try { menuBgmEl.pause(); } catch {}
            }

            // 用户开始游戏时尝试播放背景音乐（默认开启）
            applyBgmState(bgmEnabled, 'startGame');
            showBackMenuBtn(true);
        }

        function animate() { requestAnimationFrame(animate); updateGame(); renderer.render(scene, camera); }
        initThree(); animate();
    </script>
    <body>
    </body>
</html>